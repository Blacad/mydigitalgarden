---
{"dg-publish":true,"permalink":"/Toollectures/Lecture 6 Git/","dgPassFrontmatter":true}
---


# Source
---
- 中文[笔记](https://missing-semester-cn.github.io/2020/version-control/)
# Git 的数据模型
---
## 快照
- git 术语
	- 文件 - Blob
	- 目录 - tree
- 快照是被追踪的最顶层的树
## 历史记录建模： 关联快照
- 在 Git 中，历史记录是一个由快照组成的==有向无环==图
- 在 Git 中，这些快照被称为“提交”
## 数据模型的伪代码表示
### 对象和内存寻址
- Git 对象
	- Blob - 文件
	- tree - 目录
	- commit - 提交
- Git 在存储数据时所有对象都基于它们的`SHA-1 哈希` 寻址 ，Git 的对象均存储在一个hashtable中，hashtable的键是对象的哈希值，值是对象本身
### 引用
- 哈希值难以记住，因此Git采用了引用的方法，将哈希值赋予人类可理解的名字，相当于再建立一个hashtable， 键是对象的引用即名字，值是对象的哈希值
### 仓库
- Git 仓库的粗略定义是对象和引用
- 在硬盘上Git 只存储对象和引用
# 暂存区
---
- 暂存区允许指定下次快照需要包含的更改
# Git 的命令行接口
---
- 常用的 Git 命令
	- `git init`
	- `git status`
	- `git log --stat`
	- `git add`
	- `git commit -m "Init"` 
	- `git commit -amend` 补交，相当于将上次提交和本次提交合并为一次提交
	- `git diff` 查看未暂存修改
	- `git diff --staged` 查看已暂存修改
	- `git branch`
	- `git push <远程主机名> <本地分支名>:<远程分支名>`
	- `git pull <远程主机名> <远程分支名>:<本地分支名>`
- 学习[资源](https://git-scm.com/book/zh/v2)
	- 直接用 Git 的场景实际上很少，并且不太友好，一般都是和编译器联动的 Git 操作
- Git 区域
	- 工作区 - 表现为追踪的文件，它们被修改后会进入修改但未暂存
	- 暂存区 - 表现为 `git add` 后的文件，它们的修改被记录在暂存区
	- 版本库 - 表现为 `git commit` 后的文件，它们从暂存区被提交到版本库，实现了稳定的存储，之前两个区域是不稳定的
	- 远端库 - 表现为提交到远端仓库的文件，它们存储到云端，是十分安全的
	- 实践上初次初始化 Git 时是比较特殊的，当我们在一个文件夹中使用 `git init` 后，该文件夹就纳入了 Git 的控制，但是Git 中的文件最开始是空的，所有文件都是未追踪，我们将需要版本控制的文件加入到 Git ，忽略的文件加入到 `.gitignore` ，接下来就是初次提交，之后的工作流程就如遵循四个区域来做
	- 工作流：我们在工作时，一小部分成功后就暂存，接着完成本模块功能就提交，然后可以同时push
	- 日常需求
		- 代价计算是在严格遵循工作流的基础上
		- 我们在工作中可能遇到工作区的部分代码被误删或误改了，导致项目不能正常运行，我们需要回溯到之前的状态，那么我们进入 Git 一定会发现有未暂存的更改，我们直接丢弃工作区的修改，就会回到上次暂存更改的状态（不小心会丢失一个小部分的工作量）
		- 我们在工作时发现暂存后的更改有问题，需要回溯，那么我们需要将该更改先退出暂存区，然后在工作区回溯到最近提交版本，==因此暂存的时候要小心确保没有问题，因为暂存会覆盖上次暂存且无法回溯==（不小心会丢失几个小部分的工作量）
		- 我们发现版本有问题，就只能向上个版本回退，==因此版本提交的时候要小心==（不小心会丢失一个模块的工作量）
---
# 本节作业
---
- 1. 基本了解会用就行，因为正常的 Git 都是联动的
- 3. 本题解答应该有时会用到